{"remainingRequest":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!E:\\WebStormProject\\blog-vue-typescript\\src\\views\\home2.vue?vue&type=script&lang=ts&","dependencies":[{"path":"E:\\WebStormProject\\blog-vue-typescript\\src\\views\\home2.vue","mtime":1573287108449},{"path":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\ts-loader\\index.js","mtime":1545640398000},{"path":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n// 这是波浪效果，要先在 public index.html 里面引用了 three.min.js 才能用\r\n\r\nimport { Component, Vue } from \"vue-property-decorator\";\r\n\r\n@Component({})\r\nexport default class Home extends Vue {\r\n  mounted() {\r\n    var SEPARATION: number = 100,\r\n      AMOUNTX: number = 50,\r\n      AMOUNTY: number = 50;\r\n\r\n    var container: any;\r\n    var camera: any, scene: any, renderer: any;\r\n\r\n    var particles: any,\r\n      count: number = 0;\r\n\r\n    var mouseX: number = 0,\r\n      mouseY: number = 0;\r\n\r\n    var windowHalfX: any = window.innerWidth / 2;\r\n    var windowHalfY: any = window.innerHeight / 2;\r\n\r\n    setTimeout(() => {\r\n      init();\r\n      animate();\r\n    }, 10);\r\n\r\n    function init() {\r\n      container = document.getElementById(\"wave\");\r\n      container.style.position = \"fixed\";\r\n      container.style.top = \"0\";\r\n      container.style.left = \"0\";\r\n      container.style.zIndex = \"-1\";\r\n      container.style.opacity = \"1\";\r\n      // document.body.appendChild(container);\r\n\r\n      camera = new THREE.PerspectiveCamera(\r\n        75,\r\n        window.innerWidth / window.innerHeight,\r\n        1,\r\n        10000\r\n      );\r\n      camera.position.z = 1000;\r\n\r\n      scene = new THREE.Scene();\r\n\r\n      var numParticles: any = AMOUNTX * AMOUNTY;\r\n\r\n      var positions: any = new Float32Array(numParticles * 3);\r\n      var scales: any = new Float32Array(numParticles);\r\n\r\n      var i: any = 0,\r\n        j: any = 0;\r\n\r\n      for (var ix = 0; ix < AMOUNTX; ix++) {\r\n        for (var iy = 0; iy < AMOUNTY; iy++) {\r\n          positions[i] = ix * SEPARATION - (AMOUNTX * SEPARATION) / 2; // x\r\n          positions[i + 1] = 0; // y\r\n          positions[i + 2] = iy * SEPARATION - (AMOUNTY * SEPARATION) / 2; // z\r\n\r\n          scales[j] = 1;\r\n\r\n          i += 3;\r\n          j++;\r\n        }\r\n      }\r\n\r\n      var geometry: any = new THREE.BufferGeometry();\r\n      geometry.addAttribute(\r\n        \"position\",\r\n        new THREE.BufferAttribute(positions, 3)\r\n      );\r\n      geometry.addAttribute(\"scale\", new THREE.BufferAttribute(scales, 1));\r\n\r\n      var material: any = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n          color: { value: new THREE.Color(0x1890ff) }\r\n        },\r\n        vertexShader:\r\n          \"attribute float scale;void main() {vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );gl_PointSize = scale * ( 300.0 / - mvPosition.z );gl_Position = projectionMatrix * mvPosition;}\",\r\n        fragmentShader:\r\n          \"uniform vec3 color;void main() {if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;gl_FragColor = vec4( color, 1.0 );}\"\r\n      });\r\n\r\n      particles = new THREE.Points(geometry, material);\r\n      scene.add(particles);\r\n\r\n      renderer = new THREE.WebGLRenderer({ antialias: true });\r\n      renderer.setClearColor(0xffffff, 1.0);\r\n      renderer.setPixelRatio(window.devicePixelRatio);\r\n      renderer.setSize(window.innerWidth, window.innerHeight);\r\n      container.appendChild(renderer.domElement);\r\n\r\n      document.addEventListener(\"mousemove\", onDocumentMouseMove, false);\r\n      document.addEventListener(\"touchstart\", onDocumentTouchStart, false);\r\n      document.addEventListener(\"touchmove\", onDocumentTouchMove, false);\r\n\r\n      window.addEventListener(\"resize\", onWindowResize, false);\r\n    }\r\n\r\n    function onWindowResize() {\r\n      windowHalfX = window.innerWidth / 2;\r\n      windowHalfY = window.innerHeight / 2;\r\n\r\n      camera.aspect = window.innerWidth / window.innerHeight;\r\n      camera.updateProjectionMatrix();\r\n\r\n      renderer.setSize(window.innerWidth, window.innerHeight);\r\n    }\r\n\r\n    function onDocumentMouseMove(event: any) {\r\n      mouseX = event.clientX - windowHalfX;\r\n      mouseY = event.clientY - windowHalfY;\r\n    }\r\n\r\n    function onDocumentTouchStart(event: any) {\r\n      if (event.touches.length === 1) {\r\n        event.preventDefault();\r\n\r\n        mouseX = event.touches[0].pageX - windowHalfX;\r\n        mouseY = event.touches[0].pageY - windowHalfY;\r\n      }\r\n    }\r\n\r\n    function onDocumentTouchMove(event: any) {\r\n      if (event.touches.length === 1) {\r\n        event.preventDefault();\r\n\r\n        mouseX = event.touches[0].pageX - windowHalfX;\r\n        mouseY = event.touches[0].pageY - windowHalfY;\r\n      }\r\n    }\r\n\r\n    function animate() {\r\n      requestAnimationFrame(animate);\r\n\r\n      render();\r\n    }\r\n\r\n    function render() {\r\n      camera.position.x += (mouseX - camera.position.x) * 0.05;\r\n      camera.position.y += (-mouseY - camera.position.y) * 0.05;\r\n      camera.lookAt(scene.position);\r\n\r\n      var positions = particles.geometry.attributes.position.array;\r\n      var scales = particles.geometry.attributes.scale.array;\r\n\r\n      var i = 0,\r\n        j = 0;\r\n\r\n      for (var ix = 0; ix < AMOUNTX; ix++) {\r\n        for (var iy = 0; iy < AMOUNTY; iy++) {\r\n          positions[i + 1] =\r\n            Math.sin((ix + count) * 0.3) * 50 +\r\n            Math.sin((iy + count) * 0.5) * 50;\r\n\r\n          scales[j] =\r\n            (Math.sin((ix + count) * 0.3) + 1) * 8 +\r\n            (Math.sin((iy + count) * 0.5) + 1) * 8;\r\n\r\n          i += 3;\r\n          j++;\r\n        }\r\n      }\r\n\r\n      particles.geometry.attributes.position.needsUpdate = true;\r\n      particles.geometry.attributes.scale.needsUpdate = true;\r\n\r\n      renderer.render(scene, camera);\r\n\r\n      count += 0.1;\r\n    }\r\n  }\r\n}\r\n",null]}