{"remainingRequest":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\babel-loader\\lib\\index.js!E:\\WebStormProject\\blog-vue-typescript\\src\\utils\\markdown.js","dependencies":[{"path":"E:\\WebStormProject\\blog-vue-typescript\\src\\utils\\markdown.js","mtime":1573558720916},{"path":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"E:\\\\WebStormProject\\\\blog-vue-typescript\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"E:\\\\WebStormProject\\\\blog-vue-typescript\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"E:\\\\WebStormProject\\\\blog-vue-typescript\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport \"core-js/modules/es6.string.anchor\";\n\n// https://www.cherylgood.cn/detail/5bdaf4722382b4646c27143b.html\nvar _highlight = require(\"highlight.js\");\n\nvar _marked = require(\"marked\");\n\nvar tocObj = {\n  add: function add(text, level) {\n    var anchor = \"#toc\".concat(level).concat(++this.index);\n    this.toc.push({\n      anchor: anchor,\n      level: level,\n      text: text\n    });\n    return anchor;\n  },\n  // 使用堆栈的方式处理嵌套的ul,li，level即ul的嵌套层次，1是最外层\n  // <ul>\n  //   <li></li>\n  //   <ul>\n  //     <li></li>\n  //   </ul>\n  //   <li></li>\n  // </ul>\n  toHTML: function toHTML() {\n    var levelStack = [];\n    var result = \"\";\n\n    var addStartUL = function addStartUL() {\n      result += '<ul class=\"anchor-ul\" id=\"anchor-fix\">';\n    };\n\n    var addEndUL = function addEndUL() {\n      result += \"</ul>\\n\";\n    };\n\n    var addLI = function addLI(anchor, text) {\n      result += '<li><a class=\"toc-link\" href=\"#' + anchor + '\">' + text + \"<a></li>\\n\";\n    };\n\n    this.toc.forEach(function (item) {\n      var levelIndex = levelStack.indexOf(item.level); // 没有找到相应level的ul标签，则将li放入新增的ul中\n\n      if (levelIndex === -1) {\n        levelStack.unshift(item.level);\n        addStartUL();\n        addLI(item.anchor, item.text);\n      } // 找到了相应level的ul标签，并且在栈顶的位置则直接将li放在此ul下\n      else if (levelIndex === 0) {\n          addLI(item.anchor, item.text);\n        } // 找到了相应level的ul标签，但是不在栈顶位置，需要将之前的所有level出栈并且打上闭合标签，最后新增li\n        else {\n            while (levelIndex--) {\n              levelStack.shift();\n              addEndUL();\n            }\n\n            addLI(item.anchor, item.text);\n          }\n    }); // 如果栈中还有level，全部出栈打上闭合标签\n\n    while (levelStack.length) {\n      levelStack.shift();\n      addEndUL();\n    } // 清理先前数据供下次使用\n\n\n    this.toc = [];\n    this.index = 0;\n    return result;\n  },\n  toc: [],\n  index: 0\n};\n\nvar MarkUtils =\n/*#__PURE__*/\nfunction () {\n  function MarkUtils() {\n    _classCallCheck(this, MarkUtils);\n\n    this.rendererMD = new _marked.Renderer();\n\n    this.rendererMD.heading = function (text, level, raw) {\n      var anchor = tocObj.add(text, level);\n      return \"<h\".concat(level, \" id=\").concat(anchor, \">\").concat(text, \"</h\").concat(level, \">\\n\");\n    };\n\n    this.rendererMD.table = function (header, body) {\n      return '<table class=\"table\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\">' + header + body + '</table>';\n    };\n\n    _highlight.configure({\n      useBR: true\n    });\n\n    _marked.setOptions({\n      renderer: this.rendererMD,\n      headerIds: false,\n      gfm: true,\n      tables: true,\n      breaks: false,\n      pedantic: false,\n      sanitize: false,\n      smartLists: true,\n      smartypants: false,\n      highlight: function highlight(code) {\n        return _highlight.highlightAuto(code).value;\n      }\n    });\n  }\n\n  _createClass(MarkUtils, [{\n    key: \"marked\",\n    value: function () {\n      var _marked2 = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(data) {\n        var content, toc;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!data) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 3;\n                return _marked(data);\n\n              case 3:\n                content = _context.sent;\n                toc = tocObj.toHTML();\n                return _context.abrupt(\"return\", {\n                  content: content,\n                  toc: toc\n                });\n\n              case 8:\n                return _context.abrupt(\"return\", null);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function marked(_x) {\n        return _marked2.apply(this, arguments);\n      }\n\n      return marked;\n    }()\n  }]);\n\n  return MarkUtils;\n}();\n\nvar markdown = new MarkUtils();\nexport default markdown;",{"version":3,"sources":["E:\\WebStormProject\\blog-vue-typescript\\src\\utils\\markdown.js"],"names":["highlight","require","marked","tocObj","add","text","level","anchor","index","toc","push","toHTML","levelStack","result","addStartUL","addEndUL","addLI","forEach","item","levelIndex","indexOf","unshift","shift","length","MarkUtils","rendererMD","Renderer","heading","raw","table","header","body","configure","useBR","setOptions","renderer","headerIds","gfm","tables","breaks","pedantic","sanitize","smartLists","smartypants","code","highlightAuto","value","data","content","markdown"],"mappings":"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","sourcesContent":["// https://www.cherylgood.cn/detail/5bdaf4722382b4646c27143b.html\r\nconst highlight = require(\"highlight.js\");\r\nconst marked = require(\"marked\");\r\nconst tocObj = {\r\n  add: function (text, level) {\r\n    var anchor = `#toc${level}${++this.index}`;\r\n    this.toc.push({ anchor: anchor, level: level, text: text });\r\n    return anchor;\r\n  },\r\n  // 使用堆栈的方式处理嵌套的ul,li，level即ul的嵌套层次，1是最外层\r\n  // <ul>\r\n  //   <li></li>\r\n  //   <ul>\r\n  //     <li></li>\r\n  //   </ul>\r\n  //   <li></li>\r\n  // </ul>\r\n  toHTML: function () {\r\n    let levelStack = [];\r\n    let result = \"\";\r\n    const addStartUL = () => {\r\n      result += '<ul class=\"anchor-ul\" id=\"anchor-fix\">';\r\n    };\r\n    const addEndUL = () => {\r\n      result += \"</ul>\\n\";\r\n    };\r\n    const addLI = (anchor, text) => {\r\n      result +=\r\n        '<li><a class=\"toc-link\" href=\"#' + anchor + '\">' + text + \"<a></li>\\n\";\r\n    };\r\n\r\n    this.toc.forEach(function (item) {\r\n      let levelIndex = levelStack.indexOf(item.level);\r\n      // 没有找到相应level的ul标签，则将li放入新增的ul中\r\n      if (levelIndex === -1) {\r\n        levelStack.unshift(item.level);\r\n        addStartUL();\r\n        addLI(item.anchor, item.text);\r\n      } // 找到了相应level的ul标签，并且在栈顶的位置则直接将li放在此ul下\r\n      else if (levelIndex === 0) {\r\n        addLI(item.anchor, item.text);\r\n      } // 找到了相应level的ul标签，但是不在栈顶位置，需要将之前的所有level出栈并且打上闭合标签，最后新增li\r\n      else {\r\n        while (levelIndex--) {\r\n          levelStack.shift();\r\n          addEndUL();\r\n        }\r\n        addLI(item.anchor, item.text);\r\n      }\r\n    });\r\n    // 如果栈中还有level，全部出栈打上闭合标签\r\n    while (levelStack.length) {\r\n      levelStack.shift();\r\n      addEndUL();\r\n    }\r\n    // 清理先前数据供下次使用\r\n    this.toc = [];\r\n    this.index = 0;\r\n    return result;\r\n  },\r\n  toc: [],\r\n  index: 0\r\n};\r\n\r\nclass MarkUtils {\r\n  constructor() {\r\n    this.rendererMD = new marked.Renderer();\r\n    this.rendererMD.heading = function (text, level, raw) {\r\n      var anchor = tocObj.add(text, level);\r\n      return `<h${level} id=${anchor}>${text}</h${level}>\\n`;\r\n    };\r\n    this.rendererMD.table = function (header, body) {\r\n      return '<table class=\"table\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\">' + header + body + '</table>'\r\n    }\r\n    highlight.configure({ useBR: true });\r\n    marked.setOptions({\r\n      renderer: this.rendererMD,\r\n      headerIds: false,\r\n      gfm: true,\r\n      tables: true,\r\n      breaks: false,\r\n      pedantic: false,\r\n      sanitize: false,\r\n      smartLists: true,\r\n      smartypants: false,\r\n      highlight: function (code) {\r\n        return highlight.highlightAuto(code).value;\r\n      }\r\n    });\r\n  }\r\n\r\n  async marked(data) {\r\n    if (data) {\r\n      let content = await marked(data);\r\n      let toc = tocObj.toHTML();\r\n      return { content: content, toc: toc };\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nconst markdown = new MarkUtils();\r\n\r\nexport default markdown;\r\n"]}]}