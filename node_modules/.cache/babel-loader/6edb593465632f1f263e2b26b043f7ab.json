{"remainingRequest":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\thread-loader\\dist\\cjs.js!E:\\WebStormProject\\blog-vue-typescript\\node_modules\\babel-loader\\lib\\index.js!E:\\WebStormProject\\blog-vue-typescript\\src\\utils\\markdown.js","dependencies":[{"path":"E:\\WebStormProject\\blog-vue-typescript\\src\\utils\\markdown.js","mtime":1573558720916},{"path":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\WebStormProject\\blog-vue-typescript\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"E:\\\\WebStormProject\\\\blog-vue-typescript\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"E:\\\\WebStormProject\\\\blog-vue-typescript\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"E:\\\\WebStormProject\\\\blog-vue-typescript\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\nimport \"core-js/modules/es6.string.anchor\";\n\n// https://www.cherylgood.cn/detail/5bdaf4722382b4646c27143b.html\nvar _highlight = require(\"highlight.js\");\n\nvar _marked = require(\"marked\");\n\nvar tocObj = {\n  add: function add(text, level) {\n    var anchor = \"#toc\".concat(level).concat(++this.index);\n    this.toc.push({\n      anchor: anchor,\n      level: level,\n      text: text\n    });\n    return anchor;\n  },\n  // 使用堆栈的方式处理嵌套的ul,li，level即ul的嵌套层次，1是最外层\n  // <ul>\n  //   <li></li>\n  //   <ul>\n  //     <li></li>\n  //   </ul>\n  //   <li></li>\n  // </ul>\n  toHTML: function toHTML() {\n    var levelStack = [];\n    var result = \"\";\n\n    var addStartUL = function addStartUL() {\n      result += '<ul class=\"anchor-ul\" id=\"anchor-fix\">';\n    };\n\n    var addEndUL = function addEndUL() {\n      result += \"</ul>\\n\";\n    };\n\n    var addLI = function addLI(anchor, text) {\n      result += '<li><a class=\"toc-link\" href=\"#' + anchor + '\">' + text + \"<a></li>\\n\";\n    };\n\n    this.toc.forEach(function (item) {\n      var levelIndex = levelStack.indexOf(item.level); // 没有找到相应level的ul标签，则将li放入新增的ul中\n\n      if (levelIndex === -1) {\n        levelStack.unshift(item.level);\n        addStartUL();\n        addLI(item.anchor, item.text);\n      } // 找到了相应level的ul标签，并且在栈顶的位置则直接将li放在此ul下\n      else if (levelIndex === 0) {\n          addLI(item.anchor, item.text);\n        } // 找到了相应level的ul标签，但是不在栈顶位置，需要将之前的所有level出栈并且打上闭合标签，最后新增li\n        else {\n            while (levelIndex--) {\n              levelStack.shift();\n              addEndUL();\n            }\n\n            addLI(item.anchor, item.text);\n          }\n    }); // 如果栈中还有level，全部出栈打上闭合标签\n\n    while (levelStack.length) {\n      levelStack.shift();\n      addEndUL();\n    } // 清理先前数据供下次使用\n\n\n    this.toc = [];\n    this.index = 0;\n    return result;\n  },\n  toc: [],\n  index: 0\n};\n\nvar MarkUtils =\n/*#__PURE__*/\nfunction () {\n  function MarkUtils() {\n    _classCallCheck(this, MarkUtils);\n\n    this.rendererMD = new _marked.Renderer();\n\n    this.rendererMD.heading = function (text, level, raw) {\n      var anchor = tocObj.add(text, level);\n      return \"<h\".concat(level, \" id=\").concat(anchor, \">\").concat(text, \"</h\").concat(level, \">\\n\");\n    };\n\n    this.rendererMD.table = function (header, body) {\n      return '<table class=\"table\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\">' + header + body + '</table>';\n    };\n\n    _highlight.configure({\n      useBR: true\n    });\n\n    _marked.setOptions({\n      renderer: this.rendererMD,\n      headerIds: false,\n      gfm: true,\n      tables: true,\n      breaks: false,\n      pedantic: false,\n      sanitize: false,\n      smartLists: true,\n      smartypants: false,\n      highlight: function highlight(code) {\n        return _highlight.highlightAuto(code).value;\n      }\n    });\n  }\n\n  _createClass(MarkUtils, [{\n    key: \"marked\",\n    value: function () {\n      var _marked2 = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(data) {\n        var content, toc;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!data) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 3;\n                return _marked(data);\n\n              case 3:\n                content = _context.sent;\n                toc = tocObj.toHTML();\n                return _context.abrupt(\"return\", {\n                  content: content,\n                  toc: toc\n                });\n\n              case 8:\n                return _context.abrupt(\"return\", null);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function marked(_x) {\n        return _marked2.apply(this, arguments);\n      }\n\n      return marked;\n    }()\n  }]);\n\n  return MarkUtils;\n}();\n\nvar markdown = new MarkUtils();\nexport default markdown;",null]}